----------------------------- MODULE AbsJupiter -----------------------------
(*
Abstract Jupiter, inspired by the COT algorithm proposed by Sun and Sun.
See their paper published on TPDS'2009.
*)
EXTENDS JupiterSerial
-----------------------------------------------------------------------------
VARIABLES
    copss   \* copss[r]: the state space (i.e., a set) of Cops maintained at replia r \in Replica
    
vars == <<intVars, ctxVars, serialVars, copss>>
-----------------------------------------------------------------------------
TypeOK ==
    /\ TypeOKInt
    /\ TypeOKCtx
    /\ TypeOKSerial
    /\ Comm(Cop)!TypeOK
    /\ copss \in [Replica -> SUBSET Cop]
-----------------------------------------------------------------------------
Init ==
    /\ InitInt
    /\ InitCtx
    /\ InitSerial
    /\ Comm(Cop)!Init
    /\ copss = [r \in Replica |-> {}]
-----------------------------------------------------------------------------
RECURSIVE xForm(_, _)
xForm(cop, r) ==
    LET ctxDiff == ds[r] \ cop.ctx  \* THEOREM: cop.ctx \subseteq ds[r]
        RECURSIVE xFormHelper(_, _, _)
        xFormHelper(coph, ctxDiffh, copssr) ==  \* 'h' stands for "helper"
            IF ctxDiffh = {} 
            THEN <<coph, copssr>>
            ELSE LET foph == CHOOSE op \in ctxDiffh: \* the first op (specifically, oid) in serial
                                \A opprime \in ctxDiffh: 
                                    opprime # op => tb(op, opprime, serial[r])
                     fcophDict == {op \in copssr: op.oid = foph /\ op.ctx = coph.ctx}
                     fcoph == CHOOSE op \in fcophDict: TRUE \* THEOREM: Cardinality(fophDict) = 1
                     cophx == COT(coph, fcoph)
                     fcophx == COT(fcoph, coph)
                  IN xFormHelper(cophx, ctxDiffh \ {foph}, copssr \cup {cophx, fcophx})
     IN xFormHelper(cop, ctxDiff, copss[r]) 

Perform(cop, r) ==
    LET xform == xForm(cop, r)  \* <<xcop, xcopss>> 
        xcop == xform[1] 
        xcopssr == xform[2]
     IN /\ state' = [state EXCEPT ![r] = Apply(xcop.op, @)]
        /\ copss' = [copss EXCEPT ![r] = xcopssr \cup {cop}]
-----------------------------------------------------------------------------
(*
Client c \in Client issues an operation op.
*)
DoOp(c, op) == \* op: the raw operation generated by the client c \in Client
    /\ LET cop == [op |-> op, oid |-> [c |-> c, seq |-> cseq'[c]], ctx |-> ds[c]]
       IN  /\ Perform(cop, c)
           /\ UpdateDS(c, cop)
           /\ Comm(Cop)!CSend(cop)

DoIns(c) ==
    \E ins \in {op \in Ins: op.pos \in 1 .. (Len(state[c]) + 1) /\ op.ch \in chins /\ op.pr = Priority[c]}:
        /\ DoOp(c, ins)
        /\ chins' = chins \ {ins.ch} \* We assume that all inserted elements are unique.

DoDel(c) == 
    \E del \in {op \in Del: op.pos \in 1 .. Len(state[c])}:
        /\ DoOp(c, del)
        /\ UNCHANGED chins

Do(c) == 
    /\ DoCtx(c)
    /\ DoSerial(c)
    /\ \/ DoIns(c) 
       \/ DoDel(c)
-----------------------------------------------------------------------------
Rev(c) ==
    /\ Comm(Cop)!CRev(c)
    /\ Perform(Head(cincoming[c]), c)
    /\ RevSerial(c)
    /\ RevCtx(c)
    /\ UNCHANGED chins
-----------------------------------------------------------------------------
SRev ==
    /\ Comm(Cop)!SRev
    /\ LET cop == Head(sincoming)
        IN /\ Perform(cop, Server)
           /\ Comm(Cop)!SSendSame(cop.oid.c, cop)
    /\ SRevSerial
    /\ SRevCtx
    /\ UNCHANGED chins
-----------------------------------------------------------------------------
Next ==
    \/ \E c \in Client: Do(c) \/ Rev(c)
    \/ SRev

Fairness ==
    WF_vars(SRev \/ \E c \in Client: Rev(c))

Spec == Init /\ [][Next]_vars \* /\ Fairness
-----------------------------------------------------------------------------
Compactness == 
    Comm(Cop)!EmptyChannel => Cardinality(Range(copss)) = 1
    
THEOREM Spec => Compactness
=============================================================================
\* Modification History
\* Last modified Tue Dec 18 22:10:07 CST 2018 by hengxin
\* Created Wed Dec 05 19:55:52 CST 2018 by hengxin
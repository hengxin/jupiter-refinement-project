------------------------------ MODULE CJupiter ------------------------------
(*
Model of our own CJupiter protocol.
*)
EXTENDS JupiterSerial
-----------------------------------------------------------------------------
VARIABLES
    (*
      For all replicas: the n-ary ordered state space
    *)
    css,    \* css[r]: the n-ary ordered state space at replica r \in Replica
    cur     \* cur[r]: the current node of css at replica r \in Replica

vars == <<intVars, ctxVars, serialVars, css, cur>>
-----------------------------------------------------------------------------
(*
A css is a directed graph with labeled edges, 
represented by a record with node field and edge field. 
Each node is characterized by its context, a set of oids. 
Each edge is labeled with an operation.                       
*)
IsCSS(G) ==
    /\ G = [node |-> G.node, edge |-> G.edge]
    /\ G.node \subseteq (SUBSET Oid)
    /\ G.edge \subseteq [from: G.node, to: G.node, cop: Cop]

EmptySS == [node |-> {{}}, edge |-> {}]

TypeOK == 
    /\ TypeOKInt
    /\ TypeOKCtx
    /\ TypeOKSerial
    /\ Comm(Cop)!TypeOK
    (*
      For all replicas: the n-ary ordered state space
    *)
    /\ \A r \in Replica: IsCSS(css[r])
    /\ cur \in [Replica -> SUBSET Oid]
-----------------------------------------------------------------------------
Init == 
    /\ InitInt
    /\ InitCtx
    /\ InitSerial
    /\ Comm(Cop)!Init
    (* 
      For all replicas: the n-ary ordered state space                                      
    *)
    /\ css = [r \in Replica |-> EmptySS]
    /\ cur = [r \in Replica |-> {}]
-----------------------------------------------------------------------------
(*
Locate the node in rcss (the css at replica r \in Replica) that matches the context ctx of cop.     
*)
Locate(cop, rcss) == CHOOSE n \in rcss.node : n = cop.ctx
(*
Take union of two state spaces ss1 and ss2.
*)
ss1 (+) ss2 == [node |-> ss1.node \cup ss2.node, edge |-> ss1.edge \cup ss2.edge]
(*
xForm: Iteratively transform cop with a path through the css 
at replica r \in Replica, following the first edges.
*)
xForm(cop, r) ==
    LET rcss == css[r]
        u == Locate(cop, rcss)
        v == u \cup {cop.oid}
        RECURSIVE xFormHelper(_, _, _, _, _, _)
        \* 'h' stands for "helper"; xcss: eXtra css created during transformation
        xFormHelper(uh, vh, coph, xcss, xcoph, xcurh) ==  
            IF uh = cur[r]
            THEN <<xcss, xcoph, xcurh>>
            ELSE LET fedge == CHOOSE e \in rcss.edge: 
                                /\ e.from = uh
                                /\ \A uhe \in rcss.edge: 
                                    (uhe.from = uh /\ uhe # e) => tb(e.cop.oid, uhe.cop.oid, serial[r])
                     uprime == fedge.to
                     fcop == fedge.cop
                     coph2fcop == COT(coph, fcop)
                     fcop2coph == COT(fcop, coph)
                     vprime == vh \cup {fcop.oid}
                 IN  xFormHelper(uprime, vprime, coph2fcop,
                        [xcss EXCEPT !.node = @ \cup {vprime},
                          !.edge = @ \cup {[from |-> vh, to |-> vprime, cop |-> fcop2coph],
                                           [from |-> uprime, to |-> vprime, cop |-> coph2fcop]}],
                        coph2fcop, vprime)
   IN  xFormHelper(u, v, cop, [node |-> {v}, edge |-> {[from |-> u, to |-> v, cop |-> cop]}], cop, v)
(*
Perform cop at replica r \in Replica.                             
*)
Perform(cop, r) ==
    LET xform == xForm(cop, r)  \* xform: <<xcss, xcop, xcur>>
        xcss == xform[1]
        xcop == xform[2]
        xcur == xform[3]
    IN /\ css' = [css EXCEPT ![r] = @ (+) xcss]
       /\ cur' = [cur EXCEPT ![r] = xcur]
       /\ state' = [state EXCEPT ![r] = Apply(xcop.op, @)]
-----------------------------------------------------------------------------
(*
Client c \in Client issues an operation op.
*)
DoOp(c, op) == \* op: the raw operation generated by the client c \in Client
    /\ LET cop == [op |-> op, oid |-> [c |-> c, seq |-> cseq'[c]], ctx |-> cur[c]]
       IN  /\ Perform(cop, c)
           /\ Comm(Cop)!CSend(cop)

DoIns(c) ==
    \E ins \in {op \in Ins: op.pos \in 1 .. (Len(state[c]) + 1) /\ op.ch \in chins /\ op.pr = Priority[c]}:
        /\ DoOp(c, ins)
        /\ chins' = chins \ {ins.ch} \* We assume that all inserted elements are unique.

DoDel(c) == 
    \E del \in {op \in Del: op.pos \in 1 .. Len(state[c])}:
        /\ DoOp(c, del)
        /\ UNCHANGED chins

Do(c) == 
    /\ DoCtx(c)
    /\ DoSerial(c)
    /\ \/ DoIns(c) 
       \/ DoDel(c)
(*
Client c \in Client receives a message from the Server.
*)
Rev(c) == 
    /\ Comm(Cop)!CRev(c)
    /\ Perform(Head(cincoming[c]), c)
    /\ RevSerial(c)
    /\ RevCtx(c)
    /\ UNCHANGED chins 
-----------------------------------------------------------------------------
(*
The Server receives a message.
*)
SRev == 
    /\ Comm(Cop)!SRev
    /\ LET cop == Head(sincoming)
       IN  /\ Perform(cop, Server)
           /\ Comm(Cop)!SSendSame(cop.oid.c, cop)  \* broadcast the original operation
    /\ SRevSerial
    /\ SRevCtx
    /\ UNCHANGED chins
-----------------------------------------------------------------------------
Next == 
    \/ \E c \in Client: Do(c) \/ Rev(c)
    \/ SRev
(*
Fairness: There is no requirement that the clients ever generate operations.
*)
Fairness == 
    WF_vars(SRev \/ \E c \in Client: Rev(c))

Spec == Init /\ [][Next]_vars \* /\ Fairness (We care more about safety.)
-----------------------------------------------------------------------------
(*
The compactness of CJupiter: the CSSes at all replicas are the same.
*)
Compactness == 
    Comm(Cop)!EmptyChannel => Cardinality(Range(css)) = 1

THEOREM Spec => Compactness
=============================================================================
\* Modification History
\* Last modified Sat Dec 15 17:31:20 CST 2018 by hengxin
\* Created Sat Sep 01 11:08:00 CST 2018 by hengxin